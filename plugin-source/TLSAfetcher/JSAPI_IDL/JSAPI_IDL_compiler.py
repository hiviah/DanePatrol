#!/usr/bin/env python
import sys
import re
import yaml

from yaml_ordered_loader import OrderedDictYAMLLoader

###
# JSAPI_IDL_compiler - metacompiler that generates C++ struct/class with
# autogenerated methods transforming the class data into something we can pass
# to javascript from plugin.
#
# Classes created employ FireBreath's FB::variant(_map|_list) to implement it.
#
# A bit over-engineered, but beats rewriting the JSAPI serialize/convert code by
# hand.

# Ordered dict is needed so that declared member variable order does not change.
try:
	#for Python >= 2.7
	from collections import OrderedDict
except ImportError:
	#local version taken from PyPi
	from ordereddict import OrderedDict

INCLUDES = "includes"
BASEFNAME = "output_basefname"
NAMESPACE = "namespace"

HEADER_TEMPLATE = \
"""
/* AUTOGENERATED FILE */

#ifndef H_%(basefname)s
#define H_%(basefname)s

#include <string>
#include <vector>

#include "APITypes.h"

%(includes)s

namespace %(namespace)s
{

%(forward_declarations)s

%(class_definitions)s

}

#endif /* H_%(basefname)s */
"""

CLASS_H_TEMPLATE = \
"""
struct %(class_name)s
{
	/* Constructors, destructor is default */
	%(class_name)s() {}
	%(class_name)s(%(member_init)s);
	
	/* API function to convert to JSAPI object passable to javascript */
	FB::variant toVariant() const;

	/* Member fields */
%(members)s
};
"""

CPP_TEMPLATE = \
"""
/* AUTOGENERATED FILE */

#include <vector>
#include <string>

#include "variant_list.h"
#include "variant_map.h"

#include "%(basefname)s.h"

namespace %(namespace)s
{

%(class_implementations)s
	
}

"""

#It'd be nice if we could overload or specialize FB::make_variant() or
#FB::variant_detail::...::make_variant(), but I couldn't make it work.
CLASS_CPP_TEMPLATE = \
"""
%(class_name)s::%(class_name)s(%(member_init)s):
%(initializers)s
{
}

FB::variant %(class_name)s::toVariant() const
{
	FB::VariantMap result = FB::variant_map_of<std::string> \\
		%(member_tuples)s;
	
	return result;
}
"""

class IDLType(object):
	"""Base class for types supported in IDL declaration."""
	
	def __init__(self, idlName, cppName=None):
		self.byValue = True
		self.idlName = idlName
		self.cppName = cppName if cppName else idlName
		
		#TypeMap will fill itself in here once the type is added to the map
		self.typeMap = None
	
	def getCtorDeclarator(self, idlDeclaration):
		"""Return type declaration to be used in constructor argument list.
		
		@param idlDeclaration: string how the type was declared in yaml file
		"""
		typeDecl = self.getMemberDeclarator(idlDeclaration)
		if not self.byValue:
			return "const %s&" % (typeDecl,)
		else:
			return typeDecl
		
	def getMemberDeclarator(self, idlDeclaration):
		"""Return type declaration to be used in class member declaration.
		
		@param idlDeclaration: string how the type was declared in yaml file
		"""
		return self.cppName
		
	def getJSAPIConvertExpression(self, member):
		"""Returns C++ expression which converts member of this type
		to object passable to JSAPI.
		
		This default implementation will work for types for which
		FB::variant has specialization.
		
		@param idlDeclaration: string how the type was declared in yaml file
		@param member: member name, it's used as operand in the expression
		"""
		return "%s" % member

class ValuePassedType(IDLType):
	"""Represents primitive types passed by value on function call."""
	
	def __init__(self, idlName, cppName=None):
		IDLType.__init__(self, idlName, cppName)
		self.byValue = True

class ReferencePassedType(IDLType):
	"""Represents types passed by reference on function call."""
	
	def __init__(self, idlName, cppName=None):
		IDLType.__init__(self, idlName, cppName)
		self.byValue = False

class OpaqueType(ReferencePassedType):
	"""New structs/classes defined in user's IDL file."""

	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)

class StructuredType(ReferencePassedType):
	"""Represents structured types needing parameter(s), like list or map."""
	
	#for parsing 'containtertype<InnerClass1 [, ..., InnerClassN]>'
	paramRe = re.compile(r"[a-zA-Z_]\w*\s*<\s*([a-zA-Z_]\w*(?:\s*,\s*[a-zA-Z_]\w*)?)\s*>")

	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)
	
	def getMemberDeclarator(self, idlDeclaration):
		m = self.paramRe.match(idlDeclaration)
		if not m:
		    	raise ValueError("Cannot parse structured type - " + idlDeclaration)

		innerTypes = re.split(r"\s*,\s*", m.group(1))
		innerMapped = [self.typeMap.cppEquivalent(t) for t in innerTypes]

		return "%s< %s >" % (self.cppName, ", ".join(innerMapped))
	
class ListType(StructuredType):
	"""Represents list< ... > type."""
	
	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)
	
	def getJSAPIConvertExpression(self, member):
		code = "FB::make_variant_list(%s)" % member;
		return code

class TypeMap(object):
	"""Mapping IDL objects -> C++ objects
	
	There may be only one instance of this class because we are lazy to
	deep copy type objects.
	"""

	supportedTypes = \
	[
		ValuePassedType("int"),
		ValuePassedType("bool"),
		ReferencePassedType("string", "std::string"),
		ListType("list", "std::vector"),
	]

	basetypeRe = re.compile(r"([a-zA-Z_]\w*).*")

	def __init__(self):
		self.lookup = {}
		for typeDef in TypeMap.supportedTypes:
			self.addType(typeDef)
	
	def addType(self, typeDef):
		"""Add new type to map.
		
		@param typeDef: descendant of IDLType
		"""
		self.lookup[typeDef.idlName] = typeDef
		typeDef.typeMap = self # <-- the reason only one TypeMap is allowed
	
	def findType(self, idlDeclaration):
		m = self.basetypeRe.match(idlDeclaration)
		if not m:
			raise ValueError("Invalid type declaration - " + idlDeclaration)
		
		basetype = self.lookup.get(m.group(1))
		if not basetype:
			raise ValueError("Unknown type declaration - " + idlDeclaration)
		
		return basetype

	def cppEquivalent(self, idlDeclaration):
		return self.findType(idlDeclaration).getMemberDeclarator(idlDeclaration)

class IDL(object):
	"""Represents IDL parsed from YAML"""

	reservedKeywords = set([INCLUDES, BASEFNAME, NAMESPACE])

	def __init__(self, yamlStream):
		self.idl = yaml.load(yamlStream, Loader=OrderedDictYAMLLoader)
		self.includes = self.idl.get(INCLUDES, [])
		self.basefname = self.idl[BASEFNAME]
		self.namespace = self.idl.get(NAMESPACE, "")
	
	@staticmethod
	def isKeyword(name):
		return name in IDL.reservedKeywords

	def classNames(self):
		"""Return list of class names defined in IDL"""
		return [name for name in self.idl.keys() if not IDL.isKeyword(name)]

	def classes(self):
		"""Return iterator over classes defined in IDL.

		@return: dict-style iterator over (class, members) pairs.
		"""
		return ((klass, members) for (klass, members) in self.idl.iteritems() \
			if not IDL.isKeyword(klass))

class TypeInstantiation(object):
	"""Type instantiation once declared, needed for parameterized types like list<Whatever>.
	"""
	
	def __init__(self, idlDeclaration, typeMap):
		self.idlDeclaration = idlDeclaration
		self.typeMap = typeMap
		self.typeObject = typeMap.findType(idlDeclaration)
		
		#generate type declarations strings used when writing class code
		self.ctorTypeDecl = self.typeObject.getCtorDeclarator(idlDeclaration)
		self.memberTypeDecl = self.typeObject.getMemberDeclarator(idlDeclaration)
		
class ClassGenerator(object):
	"""
	Generates code for header and cpp of a class.
	"""
	
	def __init__(self, className, classTree, typeMap):
		"""
		@param classTree: dict structure from the YAML dict that is value for the class
		"""
		self.className = className
		self.classTree = classTree
		self.typeMap = typeMap
		
		self.members = OrderedDict()
		
		for memberName, idlDeclaration in self.classTree.items():
			self.members[memberName] = TypeInstantiation(idlDeclaration, self.typeMap)
	
	def memberNames(self):
		return self.members.keys()
		
	def ctorDeclaration(self):
		decls = []
		
		for member, typeInst in self.members.iteritems():
			decls.append(typeInst.ctorTypeDecl + " " +  member)
		
		return ", ".join(decls)
		
	def memberDeclaration(self):
		decls = []
		
		for member, typeInst in self.members.iteritems():
			decls.append("\t" + typeInst.memberTypeDecl + " " +  member + ";")
		
		return "\n".join(decls)
		
	def classHeaderCode(self):
		"""Return generated text for class declaration"""
		
		classText = CLASS_H_TEMPLATE % \
		{
			"class_name": self.className,
			"members": self.memberDeclaration(),
			"member_init": self.ctorDeclaration(),
		}
		
		return classText
	
	def classCppCode(self):
		"""Return generated text for class declaration"""
		
		initializers = ["\t%s(%s)" % (m, m) for m in self.memberNames()]
		mapTuples = ["(%s, %s)" % (m, ti.typeObject.getJSAPIConvertExpression(m)) for (m, ti) in self.members.items()]
		
		classText = CLASS_CPP_TEMPLATE % \
		{
			"class_name": self.className,
			"members": self.memberDeclaration(),
			"member_init": self.ctorDeclaration(),
			"initializers": ",\n".join(initializers),
			"member_tuples": "\n\t\t".join(mapTuples),
		}
		
		return classText
	

def fillNewTypes(idl, typeMap):
	"""Add new types (user-created structs) defined in IDL to type map.
	
	@param idl: IDL instance
	@param typeMap: TypeMap instance
	"""
	for className in idl.classNames():
		typeMap.addType(OpaqueType(className))
		
def writeHeader(idl, typeMap):
	"""Generate C++ header from IDL.
	
	@param idl: IDL object created from YAML
	"""
	f = file(idl.basefname + ".h", "w")

	includes = ["#include %s" % (include,) for include in idl.includes]
	
	classNames = idl.classNames()
	classDefs = [ClassGenerator(name, idl.idl[name], typeMap).classHeaderCode() for name in classNames]

	# We won't do topological sort on class dependency, let's just
	# forward-declare it all.
	forwardDecls = ["struct %s;" % name for name in classNames]
	
	headerText = HEADER_TEMPLATE % \
		{
			"basefname": idl.basefname,
			"namespace": idl.namespace,
			"includes": "\n".join(includes),
			"class_definitions": "\n\n".join(classDefs),
			"forward_declarations": "\n".join(forwardDecls),
		}

	f.write(headerText)
	f.close()

def writeCpp(idl, typeMap):
	"""Generate C++ source from IDL"""
	f = file(idl.basefname + ".cpp", "w")

	classNames = idl.classNames()
	classDefs = [ClassGenerator(name, idl.idl[name], typeMap).classCppCode() for name in classNames]

	cppText = CPP_TEMPLATE % \
		{
			"basefname": idl.basefname,
			"namespace": idl.namespace,
			"class_implementations": "\n\n".join(classDefs),
		}

	f.write(cppText)
	f.close()
	pass

if __name__ == "__main__":

	idl = IDL(file(sys.argv[1]))
	
	globalTypeMap = TypeMap()
	fillNewTypes(idl, globalTypeMap)

	writeHeader(idl, globalTypeMap)
	writeCpp(idl, globalTypeMap)
