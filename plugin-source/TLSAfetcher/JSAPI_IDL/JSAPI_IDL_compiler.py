#!/usr/bin/env python
import sys
import re
import yaml

from yaml_ordered_loader import OrderedDictYAMLLoader

###
# JSAPI_IDL_compiler - metacompiler that generates C++ struct/class with
# autogenerated methods transforming the class data into something we can pass
# to javascript from plugin.
#
# Classes created employ FireBreath's FB::variant(_map|_list) to implement it.
#
# A bit over-engineered, but beats rewriting the JSAPI serialize/convert code by
# hand.

# Ordered dict is needed so that declared member variable order does not change.
try:
	#for Python >= 2.7
	from collections import OrderedDict
except ImportError:
	#local version taken from PyPi
	from ordereddict import OrderedDict

INCLUDES = "includes"
BASEFNAME = "output_basefname"
NAMESPACE = "namespace"
ENUMS = "enums"

HEADER_TEMPLATE = \
"""
/*
 * AUTOGENERATED FILE
 * Generator: JSAPI_IDL_compiler.py
 */

#ifndef H_%(basefname)s
#define H_%(basefname)s

#include <string>
#include <vector>

#include "variant.h"

%(includes)s

namespace %(namespace)s
{

%(enum_definitions)s

%(class_definitions)s

}

#endif /* H_%(basefname)s */
"""

CLASS_H_TEMPLATE = \
"""
struct %(class_name)s
{
	/*! No-member-fill constructor. */
	%(class_name)s() {}

	/*! Constructor setting all member fields. */
	%(class_name)s(%(member_init)s);

	/*! Virtual destructor to make inherited virtual methods possible */
	virtual ~%(class_name)s() {}

	/* API function to convert to JSAPI object passable to javascript */
	virtual FB::variant toVariant() const;

	/* Member fields */
%(members)s
};
"""

#It'd be nice if we could overload or specialize FB::make_variant() or
#FB::variant_detail::...::make_variant(), but I couldn't make it work.
CPP_TEMPLATE = \
"""
/*
 * AUTOGENERATED FILE
 * Generator: JSAPI_IDL_compiler.py
 */

#include <vector>
#include <string>
#include <iterator>
#include <algorithm>

#include "variant.h"
#include "variant_list.h"
#include "variant_map.h"
#include "APITypes.h"

#include "%(basefname)s.h"

namespace %(namespace)s
{

template <typename T>
inline FB::variant to_variant(const T& t)
{
    return FB::variant(t);
}

template <typename Inner>
inline FB::variant to_variant(const std::vector<Inner>& val)
{
    FB::VariantList vl;

    std::transform(val.begin(), val.end(), std::back_inserter(vl), &to_variant<Inner>);

    return vl;
}

%(class_implementations)s
	
}

"""

CLASS_CPP_TEMPLATE = \
"""
template <>
inline FB::variant to_variant< %(class_name)s >(const %(class_name)s& val)
{
    FB::VariantMap vm;

    %(member_assign)s

    return vm;
}

%(class_name)s::%(class_name)s(%(member_init)s):
%(initializers)s
{
}

FB::variant %(class_name)s::toVariant() const
{
	return to_variant(*this);
}
"""

JS_TEMPLATE = \
"""
/*
 * AUTOGENERATED FILE
 * Generator: JSAPI_IDL_compiler.py
 */

%(enum_definitions)s
"""

class IDLType(object):
	"""Base class for types supported in IDL declaration."""
	
	def __init__(self, idlName, cppName=None):
		self.byValue = True
		self.idlName = idlName
		self.cppName = cppName if cppName else idlName
		
		#TypeMap will fill itself in here once the type is added to the map
		self.typeMap = None
	
	def getCtorDeclarator(self, idlDeclaration):
		"""Return type declaration to be used in constructor argument list.
		
		@param idlDeclaration: string how the type was declared in yaml file
		"""
		typeDecl = self.getMemberDeclarator(idlDeclaration)
		if not self.byValue:
			return "const %s&" % (typeDecl,)
		else:
			return typeDecl
		
	def getMemberDeclarator(self, idlDeclaration):
		"""Return type declaration to be used in class member declaration.
		
		@param idlDeclaration: string how the type was declared in yaml file
		"""
		return self.cppName

class ValuePassedType(IDLType):
	"""Represents primitive types passed by value on function call."""
	
	def __init__(self, idlName, cppName=None):
		IDLType.__init__(self, idlName, cppName)
		self.byValue = True

class ReferencePassedType(IDLType):
	"""Represents types passed by reference on function call."""
	
	def __init__(self, idlName, cppName=None):
		IDLType.__init__(self, idlName, cppName)
		self.byValue = False

class OpaqueType(ReferencePassedType):
	"""New structs/classes defined in user's IDL file."""

	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)

class StructuredType(ReferencePassedType):
	"""Represents structured types needing parameter(s), like list or map."""
	
	#for parsing 'containtertype<InnerClass1 [, ..., InnerClassN]>'
	paramRe = re.compile(r"[a-zA-Z_]\w*\s*<\s*([a-zA-Z_]\w*(?:\s*,\s*[a-zA-Z_]\w*)?)\s*>")

	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)
	
	def getMemberDeclarator(self, idlDeclaration):
		m = self.paramRe.match(idlDeclaration)
		if not m:
		    	raise ValueError("Cannot parse structured type - " + idlDeclaration)

		innerTypes = re.split(r"\s*,\s*", m.group(1))
		innerMapped = [self.typeMap.cppEquivalent(t) for t in innerTypes]

		return "%s< %s >" % (self.cppName, ", ".join(innerMapped))
	
class ListType(StructuredType):
	"""Represents list< ... > type."""
	
	def __init__(self, idlName, cppName=None):
		ReferencePassedType.__init__(self, idlName, cppName)

class EnumType(ValuePassedType):
	"""Represents enum type."""
	
	def __init__(self, idlName, cppName=None, values=None):
		ValuePassedType.__init__(self, idlName, cppName)
		
		enumVal = 0
		if values is None:
			values = []
		
		self.items = OrderedDict()
		for item in values:
			if isinstance(item, dict):
				assert len(item) == 1, "Too complex enum"
				name, intVal = item.copy().popitem()
				assert isinstance(intVal, int), "Enum item's value must be int"
				
				self.items[name] = intVal
				enumVal = intVal + 1
			elif isinstance(item, basestring):
				self.items[item] = enumVal
				enumVal += 1
			else:
				raise ValueError("Unknown syntax for enum item %s.%s" % \
					(self.idlName, repr(item)))
	
	def cppDeclaration(self):
		"""Return C++ declaration of this enum."""
		itemVals = ["%s = %s" % items for items in self.items.items()]
		itemValsFmt = ",\n    ".join(itemVals)
		fmtStr = "enum %s\n{\n    %s\n};"
			
		return fmtStr % (self.cppName, itemValsFmt)

	def jsDeclaration(self):
		"""Return javascript declaration of this enum."""
		itemVals = ["%s: %s" % items for items in self.items.items()]
		itemValsFmt = ",\n    ".join(itemVals)
		fmtStr = "var %s = {\n    %s\n};"
			
		return fmtStr % (self.cppName, itemValsFmt)

class TypeMap(object):
	"""Mapping IDL objects -> C++ objects
	
	There may be only one instance of this class because we are lazy to
	deep copy type objects.
	"""

	supportedTypes = \
	[
		ValuePassedType("int"),
		ValuePassedType("bool"),
		ReferencePassedType("string", "std::string"),
		ListType("list", "std::vector"),
	]

	basetypeRe = re.compile(r"([a-zA-Z_]\w*).*")

	def __init__(self):
		self.lookup = OrderedDict()
		for typeDef in TypeMap.supportedTypes:
			self.addType(typeDef)
	
	def addType(self, typeDef):
		"""Add new type to map.
		
		@param typeDef: descendant of IDLType
		"""
		self.lookup[typeDef.idlName] = typeDef
		typeDef.typeMap = self # <-- the reason only one TypeMap is allowed
	
	def findType(self, idlDeclaration):
		"""Find type based on IDL declaration.
		
		@param idlDeclaration: string declaration of type from YAML
		"""
		m = self.basetypeRe.match(idlDeclaration)
		if not m:
			raise ValueError("Invalid type declaration - " + idlDeclaration)
		
		basetype = self.lookup.get(m.group(1))
		if not basetype:
			raise ValueError("Unknown type declaration - " + idlDeclaration)
		
		return basetype

	def cppEquivalent(self, idlDeclaration):
		"""Return name of C++ equivalent type for type used in IDL declaration.
		
		@param idlDeclaration: declaration of type from YAML
		"""
		return self.findType(idlDeclaration).getMemberDeclarator(idlDeclaration)
	
	def enumTypes(self):
		return [t for t in self.lookup.values() if isinstance(t, EnumType)]

class IDL(object):
	"""Represents IDL parsed from YAML"""

	reservedKeywords = set([INCLUDES, BASEFNAME, NAMESPACE, ENUMS])

	def __init__(self, yamlStream):
		self.idl = yaml.load(yamlStream, Loader=OrderedDictYAMLLoader)
		self.includes = self.idl.get(INCLUDES, [])
		self.basefname = self.idl[BASEFNAME]
		self.namespace = self.idl.get(NAMESPACE, "")
		
		self.enums = self.idl.get(ENUMS, OrderedDict())
	
	@staticmethod
	def isKeyword(name):
		"""Returns true iff name is in IDL reserved keywords."""
		return name in IDL.reservedKeywords

	def classNames(self):
		"""Return list of class names defined in IDL"""
		return [name for name in self.idl.keys() if not IDL.isKeyword(name)]

	def classes(self):
		"""Return iterator over classes defined in IDL.

		@return: dict-style iterator over (class, members) pairs.
		"""
		return ((klass, members) for (klass, members) in self.idl.iteritems() \
			if not IDL.isKeyword(klass))
	
	def enumNames(self):
		"""Return list of class names defined in IDL"""
		return self.enums.keys()

class TypeInstantiation(object):
	"""Type instantiation once declared, needed for parameterized types like list<Whatever>.
	"""
	
	def __init__(self, idlDeclaration, typeMap):
		self.idlDeclaration = idlDeclaration
		self.typeMap = typeMap
		self.typeObject = typeMap.findType(idlDeclaration)
		
		#generate type declarations strings used when writing class code
		self.ctorTypeDecl = self.typeObject.getCtorDeclarator(idlDeclaration)
		self.memberTypeDecl = self.typeObject.getMemberDeclarator(idlDeclaration)
		
class ClassGenerator(object):
	"""
	Generates code for header and cpp of a class.
	"""
	
	def __init__(self, className, classTree, typeMap):
		"""
		@param classTree: dict structure from the YAML dict that is value for the class
		"""
		self.className = className
		self.classTree = classTree
		self.typeMap = typeMap
		
		self.members = OrderedDict()
		
		for memberName, idlDeclaration in self.classTree.items():
			self.members[memberName] = TypeInstantiation(idlDeclaration, self.typeMap)
	
	def memberNames(self):
		"""Returns names of member fields."""
		return self.members.keys()
		
	def ctorDeclaration(self):
		"""Returns argument list for constructor with all member fields.
		
		@return: list of strings with type and member name (includes
		reference for reference-types)
		"""
		decls = []
		
		for member, typeInst in self.members.iteritems():
			decls.append(typeInst.ctorTypeDecl + " " +  member)
		
		return ", ".join(decls)
		
	def memberDeclaration(self):
		"""Returns list of member string declarations."""
		decls = []
		
		for member, typeInst in self.members.iteritems():
			decls.append("\t" + typeInst.memberTypeDecl + " " +  member + ";")
		
		return "\n".join(decls)
		
	def classHeaderCode(self):
		"""Return generated text for class declaration"""
		
		classText = CLASS_H_TEMPLATE % \
		{
			"class_name": self.className,
			"members": self.memberDeclaration(),
			"member_init": self.ctorDeclaration(),
		}
		
		return classText
	
	def classCppCode(self):
		"""Return generated text for class declaration"""
		
		initializers = ["\t%s(%s)" % (m, m) for m in self.memberNames()]
		memberAssign = ['vm["%s"] = to_variant(val.%s);' % (m, m) for m in self.memberNames()]
		
		classText = CLASS_CPP_TEMPLATE % \
		{
			"class_name": self.className,
			"members": self.memberDeclaration(),
			"member_init": self.ctorDeclaration(),
			"initializers": ",\n".join(initializers),
			"member_assign": "\n    ".join(memberAssign),
		}
		
		return classText
	

def fillNewTypes(idl, typeMap):
	"""Add new types (user-created structs) defined in IDL to type map.
	
	@param idl: IDL instance
	@param typeMap: TypeMap instance
	"""
	for className in idl.classNames():
		typeMap.addType(OpaqueType(className))
	for enumName, enumItems in idl.enums.iteritems():
		typeMap.addType(EnumType(enumName, values=enumItems))
		
def writeHeader(idl, typeMap):
	"""Generate C++ header from IDL.
	
	@param idl: IDL object created from YAML
	"""
	f = file(idl.basefname + ".h", "w")

	includes = ["#include %s" % (include,) for include in idl.includes]
	
	classNames = idl.classNames()
	classDefs = [ClassGenerator(name, idl.idl[name], typeMap).classHeaderCode() for name in classNames]
	
	enumDefs = [e.cppDeclaration() for e in typeMap.enumTypes()]

	headerText = HEADER_TEMPLATE % \
		{
			"basefname": idl.basefname,
			"namespace": idl.namespace,
			"includes": "\n".join(includes),
			"class_definitions": "\n\n".join(classDefs),
			"enum_definitions": "\n\n".join(enumDefs),
		}

	f.write(headerText)
	f.close()

def writeCpp(idl, typeMap):
	"""Generate C++ source from IDL"""
	f = file(idl.basefname + ".cpp", "w")

	classNames = idl.classNames()
	classDefs = [ClassGenerator(name, idl.idl[name], typeMap).classCppCode() for name in classNames]

	cppText = CPP_TEMPLATE % \
		{
			"basefname": idl.basefname,
			"namespace": idl.namespace,
			"class_implementations": "\n\n".join(classDefs),
		}

	f.write(cppText)
	f.close()
	pass

def writeJs(idl, typeMap):
	"""Generate javascript from IDL.
	
	@param idl: IDL object created from YAML
	"""
	f = file(idl.basefname + ".js", "w")

	enumDefs = [e.jsDeclaration() for e in typeMap.enumTypes()]

	jsText = JS_TEMPLATE % \
		{
			"enum_definitions": "\n\n".join(enumDefs),
		}

	f.write(jsText)
	f.close()

if __name__ == "__main__":

	idl = IDL(file(sys.argv[1]))
	
	globalTypeMap = TypeMap()
	fillNewTypes(idl, globalTypeMap)

	writeHeader(idl, globalTypeMap)
	writeCpp(idl, globalTypeMap)
	writeJs(idl, globalTypeMap)
